import logging
from typing import Optional, Dict, Any
import os
from prompt_toolkit import PromptSession
from kogniterm.core.llm_service import LLMService
from kogniterm.core.command_executor import CommandExecutor
from kogniterm.core.agents.bash_agent import AgentState
from kogniterm.terminal.terminal_ui import TerminalUI
from langchain_core.messages import AIMessage, HumanMessage, ToolMessage
from kogniterm.core.tools.file_update_tool import FileUpdateTool
from kogniterm.core.tools.advanced_file_editor_tool import AdvancedFileEditorTool
from rich.padding import Padding
from rich.panel import Panel
from rich.markdown import Markdown
import json
from io import StringIO # Importar StringIO
from rich.console import Console as RichConsole # Importar RichConsole

from kogniterm.core.tools.file_operations_tool import FileOperationsTool # Importar aquí

logger = logging.getLogger(__name__)

"""
This module contains the CommandApprovalHandler class, responsible for
managing command approval from the user in the KogniTerm application.
"""

class CommandApprovalHandler:
    def __init__(self, llm_service: LLMService, command_executor: CommandExecutor,
                 prompt_session: PromptSession, terminal_ui: TerminalUI, agent_state: AgentState,
                 file_update_tool: FileUpdateTool, advanced_file_editor_tool: AdvancedFileEditorTool, file_operations_tool: FileOperationsTool):
        self.llm_service = llm_service
        self.command_executor = command_executor
        self.prompt_session = prompt_session
        self.terminal_ui = terminal_ui
        self.agent_state = agent_state
        self.interrupt_queue = terminal_ui.get_interrupt_queue()
        self.file_update_tool = file_update_tool
        self.advanced_file_editor_tool = advanced_file_editor_tool
        self.file_operations_tool = file_operations_tool

    async def handle_command_approval(self, command_to_execute: str, auto_approve: bool = False,
                                 is_user_confirmation: bool = False, is_file_update_confirmation: bool = False, confirmation_prompt: Optional[str] = None,
                                 tool_name: Optional[str] = None, raw_tool_output: Optional[str] = None,
                                 original_tool_args: Optional[Dict[str, Any]] = None) -> dict:
        """
        Handles the approval process for a command generated by the agent or a user confirmation request.
        Can also handle file update confirmations by displaying a diff.
        Returns a dictionary with the updated agent state and tool message content.
        """
        # 1. Recuperar el tool_call_id del AIMessage más reciente
        tool_call_id = self.agent_state.tool_call_id_to_confirm

        # 2. Generar la explicación del comando o usar el prompt de confirmación
        explanation_text = ""
        panel_title = 'Confirmación de Comando'
        panel_content_markdown = ""
        

        diff_content = ""
        file_path = ""
        message = ""

        logger.debug(f"DEBUG HANDLER: is_file_update_confirmation (initial): {is_file_update_confirmation}")
        if is_file_update_confirmation or (raw_tool_output and tool_name in ["file_update_tool", "advanced_file_editor", "file_operations"]):
            try:
                diff_data = json.loads(raw_tool_output)
                diff_content = diff_data.get("diff", "")
                file_path = diff_data.get("path", "archivo desconocido")
                message = diff_data.get("message", f"Se detectaron cambios para '{file_path}'. Por favor, confirma para aplicar.")
                is_file_update_confirmation = True
            except json.JSONDecodeError:
                logger.error(f"Error al decodificar raw_tool_output como JSON para diff: {raw_tool_output}")
        logger.debug(f"DEBUG HANDLER: is_file_update_confirmation (after raw_tool_output check): {is_file_update_confirmation}")

        if is_file_update_confirmation:
            logger.debug("DEBUG: is_file_update_confirmation es True. Preparando panel de diff.")
            panel_title = f'Confirmación de Actualización: {file_path}'
            # Preparar el diff para mostrarlo con colores
            colored_diff_lines = []
            for line in diff_content.splitlines():
                if line.startswith('+'):
                    colored_diff_lines.append(f"[green]{line}[/green]")
                elif line.startswith('-'):
                    colored_diff_lines.append(f"[red]{line}[/red]")
                else:
                    colored_diff_lines.append(line)
            
            formatted_diff = "\n".join(colored_diff_lines)

            panel_content_markdown = Markdown(
                f"""**Actualización de Archivo Requerida:**\n{message}\n\n```diff\n{formatted_diff}\n```\n"""
            )
        elif is_user_confirmation and confirmation_prompt:
            explanation_text = confirmation_prompt
            panel_title = 'Confirmación de Usuario Requerida'
            panel_content_markdown = Markdown(f"""**Acción requerida:**\n{explanation_text}""")
        else:
            if tool_call_id:
                # Recuperar el último AIMessage para generar la explicación
                last_ai_message = None
                for msg in reversed(self.agent_state.messages):
                    if isinstance(msg, AIMessage):
                        last_ai_message = msg
                        break

                temp_history_for_explanation = [
                    msg for msg in self.agent_state.messages if msg.type != "tool"
                ]
                explanation_prompt = HumanMessage(
                    content=f"Explica en lenguaje natural y de forma concisa qué hará el siguiente comando y por qué es útil para la tarea actual. No incluyas el comando en la explicación, solo el texto explicativo. Comando: `{command_to_execute}`"
                )
                temp_history_for_explanation.append(explanation_prompt)
                
                try:
                    explanation_response = self.llm_service.invoke(temp_history_for_explanation)
                    full_response_content = ""
                    if hasattr(explanation_response, '__iter__'):
                        last_chunk_content = ""
                        for chunk in explanation_response:
                            if isinstance(chunk, AIMessage):
                                if isinstance(chunk.content, str):
                                    last_chunk_content = chunk.content
                                else:
                                    last_chunk_content = str(chunk.content)
                            elif isinstance(chunk, str):
                                last_chunk_content = chunk
                        full_response_content = last_chunk_content
                    else:
                        if isinstance(explanation_response, str):
                            full_response_content = explanation_response
                        else:
                            full_response_content = str(explanation_response)

                    explanation_text = full_response_content.strip()

                except Exception as e:
                    logger.error(f"Error al generar explicación para el comando: {e}")
                    explanation_text = f"No se pudo generar una explicación para el comando. Error: {e}"

            if not explanation_text:
                explanation_text = "No se pudo generar una explicación para el comando."
            
            panel_content_markdown = Markdown(f"""**Comando a ejecutar:**
```bash
{command_to_execute}
```
**Explicación:**
{explanation_text}""")

        # 3. Mostrar la explicación y pedir confirmación
        logger.debug(f"DEBUG: is_file_update_confirmation: {is_file_update_confirmation}")
        logger.debug(f"DEBUG: diff_content (primeras 100 chars): {diff_content[:100]}")
        logger.debug(f"DEBUG: file_path: {file_path}")
        logger.debug(f"DEBUG: message: {message}")
        logger.debug(f"DEBUG: panel_title: {panel_title}")
        logger.debug(f"DEBUG: panel_content_markdown (primeras 100 chars): {str(panel_content_markdown)[:100]}")

        logger.debug(f"DEBUG: Intentando imprimir panel con título: {panel_title}")
        self.terminal_ui.console.print(
            Panel(
                panel_content_markdown,
                border_style='yellow',
                title=panel_title
            ),
            soft_wrap=True, overflow="fold", highlight=False, markup=True, end="\n"
        )


        # 4. Solicitar aprobación al usuario
        run_action = False
        if auto_approve:
            run_action = True
            self.terminal_ui.print_message("Acción auto-aprobada.", style="yellow")
        else:
            while True:
                approval_input = await self.prompt_session.prompt_async("¿Deseas ejecutar esta acción? (s/n): ")

                if approval_input is None:
                    # Si el usuario interrumpe el prompt (ej. Ctrl+D), asumimos que deniega.
                    approval_input = "n"
                else:
                    approval_input = approval_input.lower().strip()

                if approval_input == 's':
                    run_action = True
                    break
                elif approval_input == 'n':
                    run_action = False
                    break
                else:
                    self.terminal_ui.print_message("Respuesta no válida. Por favor, responde 's' o 'n'.", style="red")

        # 5. Ejecutar el comando y manejar la salida (o procesar la confirmación del usuario)
        tool_message_content = ""
        if run_action:
            if is_file_update_confirmation:
                # Re-ejecutar la herramienta de actualización de archivo
                if tool_name == "file_update_tool":
                    result = self.file_update_tool._apply_update(file_path, original_tool_args.get("content", ""))
                    tool_message_content = json.loads(result).get("message", "")
                elif tool_name == "advanced_file_editor":
                    # Para advanced_file_editor, necesitamos re-invocar _run con confirm=True
                    # Los tool_args ya deberían contener confirm=True
                    # Adaptar original_tool_args para la re-ejecución de advanced_file_editor
                    adapted_tool_args = original_tool_args.copy()
                    new_content_to_apply = adapted_tool_args.pop("new_content", None)
                    action = adapted_tool_args.get("action")

                    if action in ["insert_line", "prepend_content", "append_content"]:
                        adapted_tool_args["content"] = new_content_to_apply
                    elif action == "replace_regex":
                        adapted_tool_args["replacement_content"] = new_content_to_apply
                    
                    result = self.advanced_file_editor_tool._run(**adapted_tool_args)
                    tool_message_content = result.get("message", "")
                elif tool_name == "file_operations":
                    operation = original_tool_args.get("operation")
                    path = original_tool_args.get("path")
                    if operation == "write_file":
                        content = original_tool_args.get("content")
                        result = self.file_operations_tool._perform_write_file(path, content)
                        tool_message_content = result
                    elif operation == "delete_file":
                        result = self.file_operations_tool._perform_delete_file(path)
                        tool_message_content = result
                    else:
                        tool_message_content = f"Operación '{operation}' no reconocida para confirmación de file_operations."
                
                self.terminal_ui.print_message(f"Confirmación de actualización para '{file_path}': Aprobado. {tool_message_content}", style="green")
            elif is_user_confirmation:
                tool_message_content = f"Confirmación de usuario: Aprobado para '{confirmation_prompt}'."
                self.terminal_ui.print_message("Acción de usuario aprobada.", style="green")
            else:
                full_command_output = ""
                try:
                    self.terminal_ui.print_message("Ejecutando comando... (Presiona Ctrl+C para cancelar)", style="yellow")

                    for output_chunk in self.command_executor.execute(command_to_execute, cwd=os.getcwd(), interrupt_queue=self.interrupt_queue):
                        full_command_output += output_chunk
                        print(output_chunk, end='', flush=True)
                    print()
                    tool_message_content = full_command_output if full_command_output.strip() else "El comando se ejecutó correctamente y no produjo ninguna salida."

                except KeyboardInterrupt:
                    self.command_executor.terminate()
                    tool_message_content = "Comando cancelado por el usuario."
                    self.terminal_ui.print_message("\n\nComando cancelado por el usuario.", style="red")
        else:
            if is_file_update_confirmation:
                tool_message_content = f"Confirmación de actualización para '{file_path}': Denegado. Cambios no aplicados."
                self.terminal_ui.print_message(f"Confirmación de actualización para '{file_path}': Denegado.", style="yellow")
            elif is_user_confirmation:
                tool_message_content = f"Confirmación de usuario: Denegado para '{confirmation_prompt}'."
                self.terminal_ui.print_message("Acción de usuario denegada.", style="yellow")
            else:
                tool_message_content = "Comando no ejecutado por el usuario."
                self.terminal_ui.print_message("Comando no ejecutado.", style="yellow")

        # 6. Añadir el mensaje al historial (AIMessage si es denegado, ToolMessage si es ejecutado)
        if run_action:
            if is_user_confirmation or is_file_update_confirmation:
                self.agent_state.messages.append(ToolMessage(content=tool_message_content))
            else:
                self.agent_state.messages.append(ToolMessage(
                    content=tool_message_content,
                    tool_call_id=tool_call_id
                ))
        else: # Acción denegada
            self.agent_state.messages.append(AIMessage(content=tool_message_content))
            self.terminal_ui.print_message("Acción denegada por el usuario.", style="yellow")

        # 7. Guardar el historial antes de la re-invocación
        self.llm_service._save_history(self.agent_state.messages)

        # 8. Devolver el estado actualizado y el contenido del ToolMessage
        return {"messages": self.agent_state.messages, "tool_message_content": tool_message_content, "approved": run_action}