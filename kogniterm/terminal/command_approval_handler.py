import logging
from typing import Optional, Dict, Any
import os
from prompt_toolkit import PromptSession
from kogniterm.core.llm_service import LLMService
from kogniterm.core.command_executor import CommandExecutor
from kogniterm.core.agents.bash_agent import AgentState
from kogniterm.terminal.terminal_ui import TerminalUI
from langchain_core.messages import AIMessage, HumanMessage, ToolMessage
from kogniterm.core.tools.file_update_tool import FileUpdateTool
from kogniterm.core.tools.advanced_file_editor_tool import AdvancedFileEditorTool
from kogniterm.core.tools.file_operations_tool import FileOperationsTool
from rich.padding import Padding
from rich.panel import Panel
from rich.markdown import Markdown
import json
from io import StringIO # Importar StringIO
from rich.console import Console as RichConsole # Importar RichConsole
from rich.text import Text # Â¡Nueva importaciÃ³n!
from rich.syntax import Syntax # Â¡Nueva importaciÃ³n!
from rich.console import Group # Â¡Nueva importaciÃ³n!

import uuid # Importar uuid

# Importar DiffRenderer para visualizaciÃ³n mejorada de diffs
from kogniterm.utils.diff_renderer import DiffRenderer

# Importar temas para mejorar visuales
try:
    from kogniterm.terminal.themes import ColorPalette, Icons
    from kogniterm.terminal.visual_components import create_separator, format_command
    THEMES_AVAILABLE = True
except ImportError:
    THEMES_AVAILABLE = False

logger = logging.getLogger(__name__)

"""
This module contains the CommandApprovalHandler class, responsible for
managing command approval from the user in the KogniTerm application.
"""

class CommandApprovalHandler:
    def __init__(self, llm_service: LLMService, command_executor: CommandExecutor,
                 prompt_session: PromptSession, terminal_ui: TerminalUI, agent_state: AgentState,
                 file_update_tool: FileUpdateTool, advanced_file_editor_tool: AdvancedFileEditorTool, file_operations_tool: FileOperationsTool):
        self.llm_service = llm_service
        self.command_executor = command_executor
        self.prompt_session = prompt_session
        self.terminal_ui = terminal_ui
        self.agent_state = agent_state
        self.interrupt_queue = terminal_ui.get_interrupt_queue()
        self.file_update_tool = file_update_tool
        self.advanced_file_editor_tool = advanced_file_editor_tool
        self.file_operations_tool = file_operations_tool
        
        # Inicializar DiffRenderer con colores del tema si estÃ¡n disponibles
        if THEMES_AVAILABLE:
            theme_colors = {
                'diff_add_color': ColorPalette.SUCCESS,
                'diff_delete_color': ColorPalette.ERROR,
                'diff_context_color': ColorPalette.TEXT_SECONDARY,
                'diff_hunk_header_color': ColorPalette.SECONDARY,
                'line_number_color': f'dim {ColorPalette.PRIMARY_LIGHT}'
            }
        else:
            theme_colors = None
        
        self.diff_renderer = DiffRenderer(theme_colors=theme_colors)

    async def handle_command_approval(self, command_to_execute: str, auto_approve: bool = False,
                                 is_user_confirmation: bool = False, is_file_update_confirmation: bool = False, confirmation_prompt: Optional[str] = None,
                                 tool_name: Optional[str] = None, raw_tool_output: Optional[str] = None,
                                 original_tool_args: Optional[Dict[str, Any]] = None) -> dict:
        logger.debug(f"DEBUG: handle_command_approval - raw_tool_output recibido: {raw_tool_output}") # <-- AÃ±adir este log
        """
        Handles the approval process for a command generated by the agent or a user confirmation request.
        Can also handle file update confirmations by displaying a diff.
        Returns a dictionary with the updated agent state and tool message content.
        """
        # 1. Recuperar el tool_call_id del AIMessage mÃ¡s reciente
        # Asegurarse de que tool_call_id siempre sea una cadena vÃ¡lida
        tool_call_id = self.agent_state.tool_call_id_to_confirm if self.agent_state.tool_call_id_to_confirm else str(uuid.uuid4())

        # 2. Generar la explicaciÃ³n del comando o usar el prompt de confirmaciÃ³n
        explanation_text = ""
        panel_title = 'ConfirmaciÃ³n de Comando'
        panel_content_markdown = ""
        full_command_output = "" # Inicializar aquÃ­
        
        is_file_update_confirmation = False
        is_plan_confirmation = False # Nueva bandera para la confirmaciÃ³n del plan
        diff_content = ""
        file_path = ""
        message = ""
        plan_title = ""
        plan_steps = []

        if isinstance(raw_tool_output, dict) and raw_tool_output.get("status") == "requires_confirmation":
            if raw_tool_output.get("operation") == "plan_creation":
                logger.debug("DEBUG: raw_tool_output es un diccionario con status: requires_confirmation y operation: plan_creation.")
                is_plan_confirmation = True
                plan_title = raw_tool_output.get("plan_title", "Plan de AcciÃ³n")
                plan_steps = raw_tool_output.get("plan_steps", [])
                message = raw_tool_output.get("message", "Se ha generado un plan. Por favor, revÃ­salo y confÃ­rmalo para proceder.")
                tool_name = "plan_creation_tool" # Asegurar que el tool_name sea correcto
            else:
                logger.debug("DEBUG: raw_tool_output es un diccionario con status: requires_confirmation.")
                diff_content = raw_tool_output.get("diff", "")
                file_path = raw_tool_output.get("path", raw_tool_output.get("args", {}).get("path", "archivo desconocido"))
                message = raw_tool_output.get("action_description", f"Se detectaron cambios para '{file_path}'. Por favor, confirma para aplicar.")
                tool_name = raw_tool_output.get("operation", tool_name) # Actualizar tool_name con la operaciÃ³n real
                original_tool_args = raw_tool_output.get("args", original_tool_args)
                logger.debug(f"DEBUG: CommandApprovalHandler - original_tool_args despuÃ©s de asignaciÃ³n: {original_tool_args}") # <-- AÃ±adir este log
                is_file_update_confirmation = True

        if is_plan_confirmation:
            logger.debug("DEBUG: is_plan_confirmation es True. Preparando panel de plan.")
            panel_title = f'ConfirmaciÃ³n de Plan: {plan_title}'
            plan_markdown = f"**{message}**\n\n"
            for step in plan_steps:
                plan_markdown += f"- **Paso {step['step']}**: {step['description']}\n"
            panel_content_markdown = Markdown(plan_markdown)

            self.terminal_ui.console.print(
                Panel(
                    panel_content_markdown,
                    border_style='cyan', # Un color diferente para los planes
                    title=panel_title
                ),
                soft_wrap=True, overflow="fold", highlight=False, markup=True, end="\n"
            )
        elif is_file_update_confirmation:
            logger.debug("DEBUG: is_file_update_confirmation es True. Preparando panel de diff.")
            panel_title = f'[bold]ConfirmaciÃ³n de ActualizaciÃ³n:[/bold] [cyan]{file_path}[/cyan]'
            if tool_name == "file_operations" and original_tool_args and original_tool_args.get("operation") == "delete_file":
                # Si es una operaciÃ³n de eliminaciÃ³n, mostrar solo la ruta del archivo
                panel_content_markdown = Markdown(
                    f"""**EliminaciÃ³n de Archivo Requerida:**\n{message}\n\n**Archivo a eliminar:**\n```\n{file_path}\n```\n"""
                )
                self.terminal_ui.console.print(
                    Panel(
                        panel_content_markdown,
                        border_style='yellow',
                        title=panel_title
                    ),
                    soft_wrap=True, overflow="fold", highlight=False, markup=True, end="\n"
                )
            else:
                # Usar DiffRenderer para visualizaciÃ³n mejorada
                diff_table = self.diff_renderer.render_diff_from_string(diff_content, file_path)
                
                # Construir el contenido del panel con el mensaje y el diff renderizado
                # Usar Markdown para el mensaje para que se renderice correctamente (**texto**)
                panel_content = Group(
                    Markdown(f"**ActualizaciÃ³n de Archivo Requerida:**\n{message}\n"),
                    diff_table
                )
                
                self.terminal_ui.console.print(
                    Panel(
                        panel_content,
                        border_style='yellow',
                        title=panel_title
                    ),
                    soft_wrap=False,
                    overflow="fold",
                    highlight=False, markup=True, end="\n"
                )
        elif is_user_confirmation and confirmation_prompt:
            explanation_text = confirmation_prompt
            panel_title = 'ConfirmaciÃ³n de Usuario Requerida'
            panel_content_markdown = Markdown(f"""**AcciÃ³n requerida:**\n{explanation_text}""")
        else:
            # Siempre intentar generar una explicaciÃ³n para el comando bash
            explanation_prompt = HumanMessage(
                content=f"Genera una explicaciÃ³n concisa del siguiente comando bash: `{command_to_execute}`. No incluyas el comando en la explicaciÃ³n, solo el texto explicativo. La explicaciÃ³n debe ser de mÃ¡ximo 2 frases."
            )
            temp_history_for_explanation = [
                msg for msg in self.agent_state.messages if msg.type != "tool"
            ]
            temp_history_for_explanation.append(explanation_prompt)
            
            try:
                explanation_response_generator = self.llm_service.invoke(temp_history_for_explanation, save_history=False) # No guardar historial para explicaciones
                full_response_content = ""
                
                # Asegurarse de que explanation_response_generator es un async generator
                for chunk in explanation_response_generator: # Siempre iterar sobre el generador
                    if isinstance(chunk, AIMessage):
                        # Si recibimos un AIMessage, solo usamos su contenido si no hemos acumulado nada vÃ­a streaming
                        # Esto evita duplicar el texto, ya que llm_service emite chunks de texto Y un AIMessage final con todo el contenido.
                        if not full_response_content and chunk.content:
                             full_response_content = chunk.content
                    elif isinstance(chunk, str):
                        full_response_content += chunk
                    else:
                        content_part = str(chunk)
                        # Evitar duplicaciÃ³n si el objeto convertido a string es igual a lo que ya tenemos (heurÃ­stica simple)
                        if content_part not in full_response_content:
                            full_response_content += content_part

                explanation_text = full_response_content.strip() if full_response_content.strip() else "No se pudo generar una explicaciÃ³n concisa." # Manejo de respuesta vacÃ­a
                logger.debug(f"DEBUG: Longitud de explanation_text: {len(explanation_text)}") # Nuevo log

            except Exception as e:
                logger.error(f"Error al generar explicaciÃ³n para el comando: {e}")
                explanation_text = f"No se pudo generar una explicaciÃ³n para el comando. Error: {e}"

            if not explanation_text:
                explanation_text = "No se pudo generar una explicaciÃ³n para el comando."
            
            panel_content_markdown = Markdown(f"""**Comando a ejecutar:**
```bash
{command_to_execute}
```
**ExplicaciÃ³n:**
{explanation_text}""")

        # 3. Mostrar la explicaciÃ³n y pedir confirmaciÃ³n
        # logger.debug(f"DEBUG: is_file_update_confirmation: {is_file_update_confirmation}")
        # logger.debug(f"DEBUG: diff_content (primeras 100 chars): {diff_content[:100]}")
        # logger.debug(f"DEBUG: file_path: {file_path}")
        # logger.debug(f"DEBUG: message: {message}")
        # logger.debug(f"DEBUG: panel_title: {panel_title}")
        # logger.debug(f"DEBUG: panel_content_markdown (primeras 100 chars): {str(panel_content_markdown)[:100]}")

        if not is_plan_confirmation and not is_file_update_confirmation: # Solo imprimir si no se imprimiÃ³ ya
            self.terminal_ui.print_confirmation_panel(
                panel_content_markdown,
                panel_title,
                'yellow'
            )
        # Forzar un re-renderizado del prompt para asegurar que el panel se muestre antes de la entrada

        # 4. Solicitar aprobaciÃ³n al usuario
        run_action = False
        if auto_approve:
            run_action = True
            self.terminal_ui.print_message("AcciÃ³n auto-aprobada.", style="yellow")
        else:
            while True:
                # logger.debug("DEBUG: Esperando input de aprobaciÃ³n del usuario...")
                try:
                    approval_input = await self.prompt_session.prompt_async("Â¿Deseas ejecutar esta acciÃ³n? (s/n): ")
                    # logger.debug(f"DEBUG: Input de aprobaciÃ³n recibido: {approval_input}")
                except Exception as e:
                    logger.error(f"ERROR: ExcepciÃ³n al solicitar input de aprobaciÃ³n: {e}", exc_info=True)
                    approval_input = "n" # Asumir denegaciÃ³n en caso de error
                
                if approval_input is None:
                    # logger.debug("DEBUG: approval_input es None. Asumiendo denegaciÃ³n.")
                    # Si el usuario interrumpe el prompt (ej. Ctrl+D), asumimos que deniega.
                    approval_input = "n"
                else:
                    approval_input = approval_input.lower().strip()
                    # logger.debug(f"DEBUG: approval_input procesado: {approval_input}")

                if approval_input == 's':
                    run_action = True
                    break
                elif approval_input == 'n':
                    run_action = False
                    break
                else:
                    self.terminal_ui.print_message("Respuesta no vÃ¡lida. Por favor, responde 's' o 'n'.", style="red")

        # 5. Ejecutar el comando y manejar la salida (o procesar la confirmaciÃ³n del usuario)
        tool_message_content = ""
        if run_action:
            if is_plan_confirmation:
                tool_message_content = json.dumps({
                    "status": "plan_approved",
                    "plan_title": plan_title,
                    "plan_steps": plan_steps,
                    "message": "Plan aprobado por el usuario."
                })
                self.terminal_ui.print_message(f"Plan '{plan_title}' aprobado. Â¡A trabajar! ðŸš€", style="green")
            elif is_file_update_confirmation:
                # Re-ejecutar la herramienta con los args originales (que ya incluyen confirm=True)
                # logger.debug(f"DEBUG: CommandApprovalHandler - tool_name en re-invocaciÃ³n: {tool_name}") # <-- AÃ±adir este log
                if tool_name == "file_update_tool":
                    result = self.file_update_tool._apply_update(file_path, original_tool_args.get("content", ""))
                    tool_message_content = json.loads(result).get("message", "")
                elif tool_name == "advanced_file_editor":
                    result = self.advanced_file_editor_tool._run(**original_tool_args)
                    tool_message_content = result.get("message", "")
                elif tool_name == "file_operations": # AÃ±adir manejo para file_operations
                    # logger.debug(f"DEBUG: CommandApprovalHandler - Re-invocando file_operations con args: {original_tool_args}") # <-- AÃ±adir este log
                    result = self.file_operations_tool._run(**original_tool_args)
                    # logger.debug(f"DEBUG: CommandApprovalHandler - Resultado de re-invocaciÃ³n de file_operations: {result}") # <-- AÃ±adir este log
                    tool_message_content = result.get("message", str(result)) if isinstance(result, dict) else str(result) # ModificaciÃ³n aquÃ­
                
                self.terminal_ui.print_message(f"ConfirmaciÃ³n de actualizaciÃ³n para '{file_path}': Aprobado. {tool_message_content}", style="green")
            elif is_user_confirmation:
                tool_message_content = f"ConfirmaciÃ³n de usuario: Aprobado para '{confirmation_prompt}'."
                self.terminal_ui.print_message("AcciÃ³n de usuario aprobada.", style="green")
            else:
                full_command_output = ""
                try:
                    # Separador visual antes del comando con temas
                    if THEMES_AVAILABLE:
                        separator_line = create_separator()
                        self.terminal_ui.console.print(separator_line)
                        self.terminal_ui.console.print(f"[bold {ColorPalette.SECONDARY}]{Icons.GEAR} Ejecutando:[/bold {ColorPalette.SECONDARY}] [{ColorPalette.SECONDARY_LIGHT}]{command_to_execute}[/{ColorPalette.SECONDARY_LIGHT}]")
                        self.terminal_ui.console.print(separator_line)
                    else:
                        # Fallback al separador original
                        separator = "â”" * 80
                        self.terminal_ui.console.print(f"\n[cyan]{separator}[/cyan]")
                        self.terminal_ui.console.print(f"[bold cyan]ðŸ”§ Ejecutando:[/bold cyan] [yellow]{command_to_execute}[/yellow]")
                        self.terminal_ui.console.print(f"[cyan]{separator}[/cyan]\n")

                    for output_chunk in self.command_executor.execute(command_to_execute, cwd=os.getcwd(), interrupt_queue=self.interrupt_queue):
                        # NO imprimir aquÃ­ - command_executor ya imprime a stdout para interactividad
                        # self.terminal_ui.print_stream(output_chunk)
                        full_command_output += output_chunk
                    
                    # Separador visual despuÃ©s del comando con temas
                    if THEMES_AVAILABLE:
                        separator_line = create_separator()
                        self.terminal_ui.console.print(separator_line)
                        self.terminal_ui.console.print(f"[bold {ColorPalette.SUCCESS}]{Icons.SUCCESS} Comando completado[/bold {ColorPalette.SUCCESS}]")
                        self.terminal_ui.console.print(separator_line)
                    else:
                        # Fallback al separador original
                        self.terminal_ui.console.print(f"\n[cyan]{separator}[/cyan]")
                        self.terminal_ui.console.print(f"[bold green]âœ“ Comando completado[/bold green]")
                        self.terminal_ui.console.print(f"[cyan]{separator}[/cyan]\n")
                    
                    
                    # Truncamiento desactivado - mostrar salida completa
                    tool_message_content = full_command_output if full_command_output.strip() else "El comando se ejecutÃ³ correctamente y no produjo ninguna salida."

                except KeyboardInterrupt:
                    self.command_executor.terminate()
                    tool_message_content = "Comando cancelado por el usuario."
                    self.terminal_ui.print_message("\n\nComando cancelado por el usuario.", style="red")
                except Exception as e:
                    raise e # Re-lanzar la excepciÃ³n
        else:
            if is_plan_confirmation:
                tool_message_content = json.dumps({
                    "status": "plan_denied",
                    "plan_title": plan_title,
                    "message": "Plan denegado por el usuario."
                })
                self.terminal_ui.print_message(f"Plan '{plan_title}' denegado. ðŸ˜”", style="yellow")
            elif is_file_update_confirmation:
                tool_message_content = f"ConfirmaciÃ³n de actualizaciÃ³n para '{file_path}': Denegado. Cambios no aplicados."
                self.terminal_ui.print_message(f"ConfirmaciÃ³n de actualizaciÃ³n para '{file_path}': Denegado.", style="yellow")
            elif is_user_confirmation:
                tool_message_content = f"ConfirmaciÃ³n de usuario: Denegado para '{confirmation_prompt}'."
                self.terminal_ui.print_message("AcciÃ³n de usuario denegada.", style="yellow")
            else:
                tool_message_content = "Comando no ejecutado por el usuario."
                self.terminal_ui.print_message("Comando no ejecutado.", style="yellow")
            full_command_output = "" # Asegurar que full_command_output siempre tenga un valor

        # 6. AÃ±adir el mensaje al historial (AIMessage si es denegado, ToolMessage si es ejecutado)
        # logger.debug(f"DEBUG: CommandApprovalHandler - run_action: {run_action}") # <-- AÃ±adir este log
        # logger.debug(f"DEBUG: CommandApprovalHandler - tool_message_content antes de aÃ±adir al historial: {tool_message_content}") # <-- AÃ±adir este log
        if run_action:
            # Si es una confirmaciÃ³n de plan, el contenido ya es un JSON que el agente puede parsear
            self.agent_state.messages.append(ToolMessage(
                content=tool_message_content,
                tool_call_id=tool_call_id # Usar el tool_call_id propagado
            ))
            # logger.debug(f"DEBUG: CommandApprovalHandler - ToolMessage aÃ±adido al historial con ID: {tool_call_id}") # <-- AÃ±adir este log
        else: # AcciÃ³n denegada
            self.agent_state.messages.append(AIMessage(content=tool_message_content))
            self.terminal_ui.print_message("AcciÃ³n denegada por el usuario.", style="yellow")
            # logger.debug("DEBUG: CommandApprovalHandler - AIMessage de denegaciÃ³n aÃ±adido al historial.") # <-- AÃ±adir este log

        # 7. Guardar el historial antes de la re-invocaciÃ³n
        self.llm_service._save_history(self.agent_state.messages)
        # logger.debug("DEBUG: CommandApprovalHandler - Historial guardado.") # <-- AÃ±adir este log

        # 8. Devolver el estado actualizado y el contenido del ToolMessage
        return {"messages": self.agent_state.messages, "tool_message_content": tool_message_content, "approved": run_action, "command_output": full_command_output}